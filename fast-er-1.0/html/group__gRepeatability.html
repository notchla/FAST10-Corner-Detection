<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>FAST-ER: Measuring the repeatability of a detector</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>Measuring the repeatability of a detector</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
Functions to load a repeatability dataset, and compute the repeatability of a list of detected points. 
<p>
<h2><a class="anchor" name="data">
The dataset</a></h2>
The dataset consists of a number of registered images. The images are stored in <code>frames/frame_X.pgm</code> where X is an integer counting from zero. The frames must all be the same size. The warps are stored in <code>waprs/warp_Y_Z.warp</code>. The file <code>warp_Y_Z.warp</code> contains one line for every pixel in image Y (pixels arranged in raster-scan order). The line is the position that the pixel warps to in image Z. If location of -1, -1 indicates that this pixel does not appear in image Z. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vector&lt; ImageRef &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gRepeatability.html#g60e1559e8d38d5bc5f9c54e2760a38b7">generate_disc</a> (int radius)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">Image&lt; bool &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gRepeatability.html#g5784016ca224d76826abed12fa051b3f">paint_circles</a> (const vector&lt; ImageRef &gt; &amp;corners, const vector&lt; ImageRef &gt; &amp;circle, ImageRef size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">float&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gRepeatability.html#gfc6a670adb399e588bec2896127337ed">compute_repeatability</a> (const vector&lt; vector&lt; Image&lt; array&lt; float, 2 &gt; &gt; &gt; &gt; &amp;warps, const vector&lt; vector&lt; ImageRef &gt; &gt; &amp;corners, int r, ImageRef size)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gRepeatability.html#g11f53e24be20774925a79be94a9e845b">compute_repeatability_exact</a> (const vector&lt; vector&lt; Image&lt; array&lt; float, 2 &gt; &gt; &gt; &gt; &amp;warps, const vector&lt; vector&lt; ImageRef &gt; &gt; &amp;corners, double r)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gRepeatability.html#g2799638ab8e578ecd380fc90a3e36a35">compute_repeatability_all</a> (const vector&lt; Image&lt; byte &gt; &gt; &amp;images, const vector&lt; vector&lt; Image&lt; array&lt; float, 2 &gt; &gt; &gt; &gt; &amp;warps, const <a class="el" href="structDetectN.html">DetectN</a> &amp;detector, const vector&lt; int &gt; &amp;cpf, double fuzz)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gRepeatability.html#g5664552986214edd235fe04b24c35c05">compute_repeatability_noise</a> (const vector&lt; Image&lt; byte &gt; &gt; &amp;images, const vector&lt; vector&lt; Image&lt; array&lt; float, 2 &gt; &gt; &gt; &gt; &amp;warps, const <a class="el" href="structDetectN.html">DetectN</a> &amp;detector, int cpf, float n, double fuzz)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gRepeatability.html#g760ab99c4eca79d376e1be1a74ce1464">mmain</a> (int argc, char **argv)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g60e1559e8d38d5bc5f9c54e2760a38b7"></a><!-- doxytag: member="learn_detector.cc::generate_disc" ref="g60e1559e8d38d5bc5f9c54e2760a38b7" args="(int radius)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;ImageRef&gt; generate_disc           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>radius</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Generate a disc of ImageRefs. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>radius</em>&nbsp;</td><td>Radius of the disc </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the disc of ImageRefs </dd></dl>

<p>Definition at line <a class="el" href="learn__detector_8cc-source.html#l00131">131</a> of file <a class="el" href="learn__detector_8cc-source.html">learn_detector.cc</a>.</p>

<p>Referenced by <a class="el" href="learn__detector_8cc-source.html#l00176">compute_repeatability()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00132"></a>00132 {
<a name="l00133"></a>00133     vector&lt;ImageRef&gt; ret;
<a name="l00134"></a>00134     ImageRef p;
<a name="l00135"></a>00135 
<a name="l00136"></a>00136     <span class="keywordflow">for</span>(p.y = -radius; p.y &lt;= radius; p.y++)
<a name="l00137"></a>00137         <span class="keywordflow">for</span>(p.x = -radius; p.x &lt;= radius; p.x++)
<a name="l00138"></a>00138             <span class="keywordflow">if</span>((<span class="keywordtype">int</span>)p.mag_squared() &lt;= radius)
<a name="l00139"></a>00139                 ret.push_back(p);
<a name="l00140"></a>00140     <span class="keywordflow">return</span> ret;
<a name="l00141"></a>00141 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g5784016ca224d76826abed12fa051b3f"></a><!-- doxytag: member="learn_detector.cc::paint_circles" ref="g5784016ca224d76826abed12fa051b3f" args="(const vector&lt; ImageRef &gt; &amp;corners, const vector&lt; ImageRef &gt; &amp;circle, ImageRef size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Image&lt;bool&gt; paint_circles           </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; ImageRef &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; ImageRef &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>circle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageRef&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Paint shapes (a vector&lt;ImageRef&gt;) safely in to an image This is used to paint discs at corner locations in order to perform rapid proximity checking. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>corners</em>&nbsp;</td><td>Locations to paint shapes </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>circle</em>&nbsp;</td><td>Shape to paint </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Image size to be painted in to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Image with shapes painted in to it. </dd></dl>

<p>Definition at line <a class="el" href="learn__detector_8cc-source.html#l00153">153</a> of file <a class="el" href="learn__detector_8cc-source.html">learn_detector.cc</a>.</p>

<p>Referenced by <a class="el" href="learn__detector_8cc-source.html#l00176">compute_repeatability()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00154"></a>00154 {   
<a name="l00155"></a>00155     Image&lt;bool&gt; im(size, 0);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157 
<a name="l00158"></a>00158     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; corners.size(); i++)
<a name="l00159"></a>00159         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; circle.size(); j++)
<a name="l00160"></a>00160             <span class="keywordflow">if</span>(im.in_image(corners[i] + circle[j]))
<a name="l00161"></a>00161                 im[corners[i] + circle[j]] = 1;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163     <span class="keywordflow">return</span> im;
<a name="l00164"></a>00164 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gfc6a670adb399e588bec2896127337ed"></a><!-- doxytag: member="learn_detector.cc::compute_repeatability" ref="gfc6a670adb399e588bec2896127337ed" args="(const vector&lt; vector&lt; Image&lt; array&lt; float, 2 &gt; &gt; &gt; &gt; &amp;warps, const vector&lt; vector&lt; ImageRef &gt; &gt; &amp;corners, int r, ImageRef size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float compute_repeatability           </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; Image&lt; array&lt; float, 2 &gt; &gt; &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>warps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; ImageRef &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ImageRef&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes repeatability the quick way, by caching, but has small rounding errors. 
<p>
This function paints a disc of <code>true</code> around each detected corner in to an image. If a corner warps to a pixel which has the value <code>true</code> then it is a repeat.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>warps</em>&nbsp;</td><td>Every warping where warps[i][j] specifies warp from image i to image j. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>corners</em>&nbsp;</td><td>Detected corners </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>A corner must be as close as this to be considered repeated </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>Size of the region for cacheing. All images must be this size. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The repeatability. </dd></dl>

<p>Definition at line <a class="el" href="learn__detector_8cc-source.html#l00176">176</a> of file <a class="el" href="learn__detector_8cc-source.html">learn_detector.cc</a>.</p>

<p>References <a class="el" href="learn__detector_8cc-source.html#l00131">generate_disc()</a>, <a class="el" href="utility_8h-source.html#l00030">ir_rounded()</a>, and <a class="el" href="learn__detector_8cc-source.html#l00153">paint_circles()</a>.</p>

<p>Referenced by <a class="el" href="learn__detector_8cc-source.html#l00258">learn_detector()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00177"></a>00177 {
<a name="l00178"></a>00178     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = corners.size();
<a name="l00179"></a>00179 
<a name="l00180"></a>00180     vector&lt;ImageRef&gt; disc = <a class="code" href="group__gRepeatability.html#g60e1559e8d38d5bc5f9c54e2760a38b7" title="Generate a disc of ImageRefs.">generate_disc</a>(r);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182     vector&lt;Image&lt;bool&gt; &gt;  detected;
<a name="l00183"></a>00183     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; n; i++)
<a name="l00184"></a>00184         detected.push_back(<a class="code" href="group__gRepeatability.html#g5784016ca224d76826abed12fa051b3f" title="Paint shapes (a vector&amp;lt;ImageRef&amp;gt;) safely in to an image This is used to paint...">paint_circles</a>(corners[i], disc, size));
<a name="l00185"></a>00185     
<a name="l00186"></a>00186     <span class="keywordtype">int</span> corners_tested = 0;
<a name="l00187"></a>00187     <span class="keywordtype">int</span> good_corners = 0;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; n; i++)
<a name="l00190"></a>00190         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; n; j++)
<a name="l00191"></a>00191         {
<a name="l00192"></a>00192             <span class="keywordflow">if</span>(i==j)
<a name="l00193"></a>00193                 <span class="keywordflow">continue</span>;
<a name="l00194"></a>00194             
<a name="l00195"></a>00195             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k &lt; corners[i].size(); k++)
<a name="l00196"></a>00196             {   
<a name="l00197"></a>00197                 ImageRef dest = <a class="code" href="group__gUtility.html#g4a600719fba70d96ffb0dac6466a7659" title="Convert a float array into an image co-ordinate.">ir_rounded</a>(warps[i][j][corners[i][k]]);
<a name="l00198"></a>00198 
<a name="l00199"></a>00199                 <span class="keywordflow">if</span>(dest.x != -1)
<a name="l00200"></a>00200                 {
<a name="l00201"></a>00201                     corners_tested++;
<a name="l00202"></a>00202                     <span class="keywordflow">if</span>(detected[j][dest])
<a name="l00203"></a>00203                         good_corners++;
<a name="l00204"></a>00204                 }
<a name="l00205"></a>00205             }
<a name="l00206"></a>00206         }
<a name="l00207"></a>00207     
<a name="l00208"></a>00208     <span class="keywordflow">return</span> 1.0 * good_corners / (DBL_EPSILON + corners_tested);
<a name="l00209"></a>00209 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g11f53e24be20774925a79be94a9e845b"></a><!-- doxytag: member="test_repeatability.cc::compute_repeatability_exact" ref="g11f53e24be20774925a79be94a9e845b" args="(const vector&lt; vector&lt; Image&lt; array&lt; float, 2 &gt; &gt; &gt; &gt; &amp;warps, const vector&lt; vector&lt; ImageRef &gt; &gt; &amp;corners, double r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double compute_repeatability_exact           </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; Image&lt; array&lt; float, 2 &gt; &gt; &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>warps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; ImageRef &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>corners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Computes repeatability the slow way to avoid rounding errors, by comparing the warped corner position to every detected corner. 
<p>
A warp to x=-1, y=? is considered to be outside the image, so it is not counted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>warps</em>&nbsp;</td><td>Every warping where warps[i][j] specifies warp from image i to image j. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>corners</em>&nbsp;</td><td>Detected corners </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>A corner must be as close as this to be considered repeated </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The repeatability. No corners means zero repeatability. </dd></dl>

<p>Definition at line <a class="el" href="test__repeatability_8cc-source.html#l00076">76</a> of file <a class="el" href="test__repeatability_8cc-source.html">test_repeatability.cc</a>.</p>

<p>Referenced by <a class="el" href="test__repeatability_8cc-source.html#l00126">compute_repeatability_all()</a>, and <a class="el" href="test__repeatability_8cc-source.html#l00161">compute_repeatability_noise()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00077"></a>00077 {
<a name="l00078"></a>00078     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = corners.size();
<a name="l00079"></a>00079 
<a name="l00080"></a>00080     <span class="keywordtype">int</span> repeatable_corners = 0;
<a name="l00081"></a>00081     <span class="keywordtype">int</span> repeated_corners = 0;
<a name="l00082"></a>00082 
<a name="l00083"></a>00083     r *= r;
<a name="l00084"></a>00084 
<a name="l00085"></a>00085     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; n; i++)
<a name="l00086"></a>00086         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; n; j++)
<a name="l00087"></a>00087         {
<a name="l00088"></a>00088             <span class="keywordflow">if</span>(i==j)
<a name="l00089"></a>00089                 <span class="keywordflow">continue</span>;
<a name="l00090"></a>00090 
<a name="l00091"></a>00091             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k &lt; corners[i].size(); k++)
<a name="l00092"></a>00092             {
<a name="l00093"></a>00093                 <span class="keyword">const</span> array&lt;float, 2&gt;&amp; p = warps[i][j][corners[i][k]];
<a name="l00094"></a>00094 
<a name="l00095"></a>00095                 <span class="keywordflow">if</span>(p[0] != -1) <span class="comment">//pixel does not warp to inside image j</span>
<a name="l00096"></a>00096                 {
<a name="l00097"></a>00097 
<a name="l00098"></a>00098                     repeatable_corners++;
<a name="l00099"></a>00099 
<a name="l00100"></a>00100                     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l=0; l &lt; corners[j].size(); l++)
<a name="l00101"></a>00101                     {
<a name="l00102"></a>00102                         Vector&lt;2&gt; d = Vec(p) - vec(corners[j][l]);
<a name="l00103"></a>00103 
<a name="l00104"></a>00104                         <span class="keywordflow">if</span>(d*d &lt; r)
<a name="l00105"></a>00105                         {
<a name="l00106"></a>00106                             repeated_corners++;
<a name="l00107"></a>00107                             <span class="keywordflow">break</span>;
<a name="l00108"></a>00108                         }
<a name="l00109"></a>00109                     }
<a name="l00110"></a>00110                 }
<a name="l00111"></a>00111             }
<a name="l00112"></a>00112         }
<a name="l00113"></a>00113     
<a name="l00114"></a>00114     <span class="keywordflow">return</span> 1.0 * (repeated_corners) / (repeatable_corners + DBL_EPSILON);
<a name="l00115"></a>00115 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g2799638ab8e578ecd380fc90a3e36a35"></a><!-- doxytag: member="test_repeatability.cc::compute_repeatability_all" ref="g2799638ab8e578ecd380fc90a3e36a35" args="(const vector&lt; Image&lt; byte &gt; &gt; &amp;images, const vector&lt; vector&lt; Image&lt; array&lt; float, 2 &gt; &gt; &gt; &gt; &amp;warps, const DetectN &amp;detector, const vector&lt; int &gt; &amp;cpf, double fuzz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_repeatability_all           </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Image&lt; byte &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; Image&lt; array&lt; float, 2 &gt; &gt; &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>warps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDetectN.html">DetectN</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>cpf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>fuzz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This wrapper function computed the repeatability for a given detector and a given container of corner densities. 
<p>
The result is printed to stdout.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>images</em>&nbsp;</td><td>Images to test repeatability on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>warps</em>&nbsp;</td><td>Every warping where warps[i][j] specifies warp from image i to image j. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detector</em>&nbsp;</td><td>Pointer to the corner detection function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpf</em>&nbsp;</td><td>The number of corners per frame to be tested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuzz</em>&nbsp;</td><td>A corner must be as close as this to be considered repeated </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="test__repeatability_8cc-source.html#l00126">126</a> of file <a class="el" href="test__repeatability_8cc-source.html">test_repeatability.cc</a>.</p>

<p>References <a class="el" href="test__repeatability_8cc-source.html#l00076">compute_repeatability_exact()</a>.</p>

<p>Referenced by <a class="el" href="test__repeatability_8cc-source.html#l00199">mmain()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00127"></a>00127 {
<a name="l00128"></a>00128     
<a name="l00129"></a>00129     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; cpf.size(); i++)
<a name="l00130"></a>00130     {
<a name="l00131"></a>00131         <span class="comment">//Detect corners in each if the frames</span>
<a name="l00132"></a>00132         vector&lt;vector&lt;ImageRef&gt; &gt; corners;
<a name="l00133"></a>00133         <span class="keywordtype">double</span>  num_corners = 0;
<a name="l00134"></a>00134 
<a name="l00135"></a>00135         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; images.size(); j++)
<a name="l00136"></a>00136         {
<a name="l00137"></a>00137             vector&lt;ImageRef&gt; c;
<a name="l00138"></a>00138             detector(images[j], c, cpf[i]);
<a name="l00139"></a>00139             corners.push_back(c);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141             num_corners += c.size();
<a name="l00142"></a>00142         }
<a name="l00143"></a>00143 
<a name="l00144"></a>00144         <span class="comment">//Compute and print the repeatability.</span>
<a name="l00145"></a>00145         cout &lt;&lt; print &lt;&lt; num_corners / images.size() &lt;&lt; <a class="code" href="group__gRepeatability.html#g11f53e24be20774925a79be94a9e845b" title="Computes repeatability the slow way to avoid rounding errors, by comparing the warped...">compute_repeatability_exact</a>(warps, corners, fuzz);
<a name="l00146"></a>00146     }
<a name="l00147"></a>00147 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g5664552986214edd235fe04b24c35c05"></a><!-- doxytag: member="test_repeatability.cc::compute_repeatability_noise" ref="g5664552986214edd235fe04b24c35c05" args="(const vector&lt; Image&lt; byte &gt; &gt; &amp;images, const vector&lt; vector&lt; Image&lt; array&lt; float, 2 &gt; &gt; &gt; &gt; &amp;warps, const DetectN &amp;detector, int cpf, float n, double fuzz)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void compute_repeatability_noise           </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; Image&lt; byte &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; Image&lt; array&lt; float, 2 &gt; &gt; &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>warps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structDetectN.html">DetectN</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>cpf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>fuzz</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This wrapper function computed the repeatability for a given detector and a given container of corner densities for variable levels of noise, from 0 to n in steps of 1 The result is printed to stdout. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>images</em>&nbsp;</td><td>Images to test repeatability on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>warps</em>&nbsp;</td><td>Every warping where warps[i][j] specifies warp from image i to image j. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detector</em>&nbsp;</td><td>Pointer to the corner detection function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cpf</em>&nbsp;</td><td>The number of corners per frame to be tested. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>The initial noise level </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fuzz</em>&nbsp;</td><td>A corner must be as close as this to be considered repeated </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="test__repeatability_8cc-source.html#l00161">161</a> of file <a class="el" href="test__repeatability_8cc-source.html">test_repeatability.cc</a>.</p>

<p>References <a class="el" href="test__repeatability_8cc-source.html#l00076">compute_repeatability_exact()</a>.</p>

<p>Referenced by <a class="el" href="test__repeatability_8cc-source.html#l00199">mmain()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00162"></a>00162 {
<a name="l00163"></a>00163         
<a name="l00164"></a>00164     <span class="keywordflow">for</span>(<span class="keywordtype">float</span> s=0; s &lt;= n; s++)
<a name="l00165"></a>00165     {
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 
<a name="l00168"></a>00168         <span class="comment">//Detect corners in each if the frames</span>
<a name="l00169"></a>00169         vector&lt;vector&lt;ImageRef&gt; &gt; corners;
<a name="l00170"></a>00170         <span class="keywordtype">double</span>  num_corners = 0;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; images.size(); j++)
<a name="l00173"></a>00173         {
<a name="l00174"></a>00174             Image&lt;byte&gt; ni = images[j].copy_from_me();
<a name="l00175"></a>00175 
<a name="l00176"></a>00176             <span class="comment">//Add noise to the image</span>
<a name="l00177"></a>00177             <span class="keywordflow">for</span>(Image&lt;byte&gt;::iterator i=ni.begin(); i != ni.end(); i++)
<a name="l00178"></a>00178                 *i = max(0, min(255, (<span class="keywordtype">int</span>)floor(*i + rand_g() * s + .5)));
<a name="l00179"></a>00179 
<a name="l00180"></a>00180             vector&lt;ImageRef&gt; c;
<a name="l00181"></a>00181             detector(ni, c, cpf);
<a name="l00182"></a>00182             corners.push_back(c);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184             num_corners += c.size();
<a name="l00185"></a>00185         }
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         <span class="comment">//Compute and print the repeatability.</span>
<a name="l00188"></a>00188         cout &lt;&lt; print &lt;&lt; s &lt;&lt; <a class="code" href="group__gRepeatability.html#g11f53e24be20774925a79be94a9e845b" title="Computes repeatability the slow way to avoid rounding errors, by comparing the warped...">compute_repeatability_exact</a>(warps, corners, fuzz) &lt;&lt; num_corners / images.size();
<a name="l00189"></a>00189     }
<a name="l00190"></a>00190 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g760ab99c4eca79d376e1be1a74ce1464"></a><!-- doxytag: member="test_repeatability.cc::mmain" ref="g760ab99c4eca79d376e1be1a74ce1464" args="(int argc, char **argv)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mmain           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>argv</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This is the driver function. 
<p>
It reads the command line arguments and calls functions to load the data and compute the repeatability.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>argc</em>&nbsp;</td><td>Number of command line argumentsd. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>argv</em>&nbsp;</td><td>Pointer to command line arguments. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="test__repeatability_8cc-source.html#l00199">199</a> of file <a class="el" href="test__repeatability_8cc-source.html">test_repeatability.cc</a>.</p>

<p>References <a class="el" href="test__repeatability_8cc-source.html#l00126">compute_repeatability_all()</a>, <a class="el" href="test__repeatability_8cc-source.html#l00161">compute_repeatability_noise()</a>, <a class="el" href="detectors_8cc-source.html#l00156">get_detector()</a>, and <a class="el" href="load__data_8cc-source.html#l00316">load_data()</a>.</p>

<p>Referenced by <a class="el" href="test__repeatability_8cc-source.html#l00231">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00200"></a>00200 {
<a name="l00201"></a>00201     GUI.LoadFile(<span class="stringliteral">"test_repeatability.cfg"</span>);
<a name="l00202"></a>00202     GUI.parseArguments(argc, argv);
<a name="l00203"></a>00203 
<a name="l00204"></a>00204     vector&lt;Image&lt;byte&gt; &gt; images;
<a name="l00205"></a>00205     vector&lt;vector&lt;Image&lt;array&lt;float, 2&gt; &gt; &gt; &gt; warps;
<a name="l00206"></a>00206 
<a name="l00207"></a>00207 
<a name="l00208"></a>00208     <span class="keywordtype">int</span> n = GV3::get&lt;int&gt;(<span class="stringliteral">"num"</span>, 2, 1);
<a name="l00209"></a>00209     <span class="keywordtype">string</span> dir = GV3::get&lt;string&gt;(<span class="stringliteral">"dir"</span>, <span class="stringliteral">"./"</span>, 1);
<a name="l00210"></a>00210     <span class="keywordtype">string</span> format = GV3::get&lt;string&gt;(<span class="stringliteral">"type"</span>, <span class="stringliteral">"cambridge"</span>, 1);
<a name="l00211"></a>00211     <span class="keywordtype">double</span> fuzz = GV3::get&lt;double&gt;(<span class="stringliteral">"r"</span>, 5, 1);
<a name="l00212"></a>00212     vector&lt;int&gt; cpf = GV3::get&lt;vector&lt;int&gt; &gt;(<span class="stringliteral">"cpf"</span>, <span class="stringliteral">"0 10 20 30 40 50 60 70 80 90 100 150 200 250 300 350 400 450 500 550 600 650 700 750 800 850 900 950 1000 1100 1200 1300 1400 1500 1600 1700 1800 1900 2000 2200"</span>, 1);
<a name="l00213"></a>00213     <span class="keywordtype">int</span> ncpf = GV3::get&lt;int&gt;(<span class="stringliteral">"ncpf"</span>, 500, 1);
<a name="l00214"></a>00214     <span class="keywordtype">float</span> nmax = GV3::get&lt;int&gt;(<span class="stringliteral">"nmax"</span>, 50, 1);
<a name="l00215"></a>00215     <span class="keywordtype">string</span> test = GV3::get&lt;string&gt;(<span class="stringliteral">"test"</span>, <span class="stringliteral">"normal"</span>, 1);
<a name="l00216"></a>00216     
<a name="l00217"></a>00217     auto_ptr&lt;DetectN&gt; detector = <a class="code" href="group__gDetect.html#g739dc004846ab5bcf575102b49185a52" title="Very simple factory function for getting detector objects.">get_detector</a>();
<a name="l00218"></a>00218 
<a name="l00219"></a>00219     rpair(images, warps) = <a class="code" href="group__gDataset.html#gdf6f4e9741d13de04fea9cbf9a5f858e" title="Load a dataset.">load_data</a>(dir, n, format);
<a name="l00220"></a>00220     
<a name="l00221"></a>00221     <span class="keywordflow">if</span>(test == <span class="stringliteral">"noise"</span>)
<a name="l00222"></a>00222         <a class="code" href="group__gRepeatability.html#g5664552986214edd235fe04b24c35c05" title="This wrapper function computed the repeatability for a given detector and a given...">compute_repeatability_noise</a>(images, warps, *detector, ncpf, nmax, fuzz);
<a name="l00223"></a>00223     <span class="keywordflow">else</span>
<a name="l00224"></a>00224         <a class="code" href="group__gRepeatability.html#g2799638ab8e578ecd380fc90a3e36a35" title="This wrapper function computed the repeatability for a given detector and a given...">compute_repeatability_all</a>(images, warps, *detector, cpf, fuzz);
<a name="l00225"></a>00225 
<a name="l00226"></a>00226 }
</pre></div>
<p>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Nov 5 10:25:01 2008 for FAST-ER by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
