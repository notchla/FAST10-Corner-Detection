<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>FAST-ER: Tree representation.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul>
</div>
<h1>Tree representation.</h1>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtree__element.html">tree_element</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This struct represents a node of the <a class="el" href="structtree.html" title="This class represents a decision tree.">tree</a>, and has pointers to other structs, thereby representing a branch or the entire <a class="el" href="structtree.html" title="This class represents a decision tree.">tree</a>.  <a href="classtree__element.html#_details">More...</a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structParseError.html">ParseError</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A named symbol to throw in the case that <a class="el" href="structtree.html" title="This class represents a decision tree.">tree</a> deserialization fails with a parse error.  <a href="structParseError.html#_details">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vector&lt; ImageRef &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gTree.html#gb5ecc2977d1b0742e65951ed075d0323">tree_detect_corners_all</a> (const Image&lt; byte &gt; &amp;im, const <a class="el" href="classtree__element.html">tree_element</a> *detector, int threshold)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">vector&lt; ImageRef &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gTree.html#g017fb812c91723281433113cd04910f7">tree_detect_corners</a> (const Image&lt; byte &gt; &amp;im, const <a class="el" href="classtree__element.html">tree_element</a> *detector, int threshold, Image&lt; int &gt; scores)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classtree__element.html">tree_element</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gTree.html#g0f1555100a7d28f0454b6ae04f4183b1">load_a_tree</a> (istream &amp;i, bool eq_branch)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classtree__element.html">tree_element</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gTree.html#gfe0dbc486b500351caf686a7a7701583">load_a_tree</a> (istream &amp;i)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">vector&lt; ImageRef &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gTree.html#g94713e5d6106835e08d8630988b823d2">transform_offsets</a> (const vector&lt; ImageRef &gt; &amp;<a class="el" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672">offsets</a>, int angle, bool r)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gTree.html#ge4ead2482e17e068c6ca4dae2e055eca">create_offsets</a> ()</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">vector&lt; vector<br>
&lt; ImageRef &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672">offsets</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gTree.html#g0b909fc1924609a5bb0dc4a364193edb">num_offsets</a></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">pair&lt; ImageRef,<br>
 ImageRef &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__gTree.html#g1fc640c768404e037aa3b77668bfd9a5">offsets_bbox</a></td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gb5ecc2977d1b0742e65951ed075d0323"></a><!-- doxytag: member="faster_tree.cc::tree_detect_corners_all" ref="gb5ecc2977d1b0742e65951ed075d0323" args="(const Image&lt; byte &gt; &amp;im, const tree_element *detector, int threshold)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;ImageRef&gt; tree_detect_corners_all           </td>
          <td>(</td>
          <td class="paramtype">const Image&lt; byte &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtree__element.html">tree_element</a> *&nbsp;</td>
          <td class="paramname"> <em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detect corners without nonmaximal suppression in an image. 
<p>
This contains a large amount of configurable debugging code to verify the correctness of the detector by comparing different implementations. High speed is achieved by converting the detector in to <a class="el" href="group__gFastTree.html">bytecode and JIT-compiling if possible</a>.<p>
The function recognises the following GVars:<ul>
<li><code>debug.verify_detections</code> Veryify JIT or bytecode detected corners using <a class="el" href="classtree__element.html#af29dc9bf366f0fa91f474f1c1a4b8fb" title="Apply the tree in all forms to detect a corner.">tree_element::detect_corner</a></li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>im</em>&nbsp;</td><td>The image to detect corners in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detector</em>&nbsp;</td><td>The corner detector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>The detector threshold. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="faster__tree_8cc-source.html#l00045">45</a> of file <a class="el" href="faster__tree_8cc-source.html">faster_tree.cc</a>.</p>

<p>References <a class="el" href="faster__tree_8h-source.html#l00050">tree_element::bbox()</a>, <a class="el" href="faster__bytecode_8h-source.html#l00099">block_bytecode::detect()</a>, <a class="el" href="faster__tree_8h-source.html#l00318">tree_element::detect_corner()</a>, and <a class="el" href="faster__tree_8h-source.html#l00092">tree_element::make_fast_detector()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00046"></a>00046 {
<a name="l00047"></a>00047     ImageRef tl, br, s;
<a name="l00048"></a>00048     rpair(tl,br) = detector-&gt;<a class="code" href="classtree__element.html#6fc18f7eff889094c9e65835d5879d5e" title="This returns the bounding box of the detector.">bbox</a>();
<a name="l00049"></a>00049     s = im.size();
<a name="l00050"></a>00050 
<a name="l00051"></a>00051     <span class="keywordtype">int</span> ymin = 1 - tl.y, ymax = s.y - 1 - br.y;
<a name="l00052"></a>00052     <span class="keywordtype">int</span> xmin = 1 - tl.x, xmax = s.x - 1 - br.x;
<a name="l00053"></a>00053 
<a name="l00054"></a>00054     ImageRef pos;
<a name="l00055"></a>00055     
<a name="l00056"></a>00056     vector&lt;int&gt; corners;
<a name="l00057"></a>00057     
<a name="l00058"></a>00058     <a class="code" href="structblock__bytecode.html" title="This struct contains a byte code compiled version of the detector.">block_bytecode</a> f2 = detector-&gt;<a class="code" href="group__gFastTree.html#gfd6c958f8187d912041cc3dec8769215" title="Compile the detector to bytecode.">make_fast_detector</a>(im.size().x);
<a name="l00059"></a>00059 
<a name="l00060"></a>00060     f2.<a class="code" href="structblock__bytecode.html#5cc546b17c7012c75fabeb3ad552c7fd" title="Detects a corner at a given pointer, with book-keeping required for score computation...">detect</a>(im, corners, threshold, xmin, xmax, ymin, ymax);
<a name="l00061"></a>00061     
<a name="l00062"></a>00062 
<a name="l00063"></a>00063     <span class="keywordflow">if</span>(GV3::get&lt;bool&gt;(<span class="stringliteral">"debug.verify_detections"</span>))
<a name="l00064"></a>00064     {
<a name="l00065"></a>00065         <span class="comment">//Detect corners using slowest, but most obvious detector, since it's most likely to </span>
<a name="l00066"></a>00066         <span class="comment">//be correct.</span>
<a name="l00067"></a>00067         vector&lt;ImageRef&gt; t;
<a name="l00068"></a>00068         <span class="keywordflow">for</span>(pos.y = ymin; pos.y &lt; ymax; pos.y++)
<a name="l00069"></a>00069         {
<a name="l00070"></a>00070             <span class="keywordflow">for</span>(pos.x = xmin; pos.x &lt; xmax; pos.x++)
<a name="l00071"></a>00071                 <span class="keywordflow">if</span>(detector-&gt;<a class="code" href="classtree__element.html#af29dc9bf366f0fa91f474f1c1a4b8fb" title="Apply the tree in all forms to detect a corner.">detect_corner</a>(im, pos, threshold))
<a name="l00072"></a>00072                     t.push_back(pos);
<a name="l00073"></a>00073         }
<a name="l00074"></a>00074 
<a name="l00075"></a>00075         <span class="comment">//Verify detected corners against this result</span>
<a name="l00076"></a>00076         <span class="keywordflow">if</span>(t.size() == corners.size())
<a name="l00077"></a>00077         {
<a name="l00078"></a>00078             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; corners.size(); i++)
<a name="l00079"></a>00079                 <span class="keywordflow">if</span>(im.data() + corners[i] != &amp; im[t[i]])
<a name="l00080"></a>00080                 {
<a name="l00081"></a>00081                     cerr &lt;&lt; <span class="stringliteral">"Fatal error: standard and fast detectors do not match!\n"</span>;
<a name="l00082"></a>00082                     cerr &lt;&lt; <span class="stringliteral">"Same number of corners, but different positions.\n"</span>;
<a name="l00083"></a>00083                     exit(1);
<a name="l00084"></a>00084                 }
<a name="l00085"></a>00085         }
<a name="l00086"></a>00086         <span class="keywordflow">else</span>
<a name="l00087"></a>00087         {
<a name="l00088"></a>00088             cerr &lt;&lt; <span class="stringliteral">"Fatal error: standard and fast detectors do not match!\n"</span>;
<a name="l00089"></a>00089             cerr &lt;&lt; <span class="stringliteral">"Different number of corners detected.\n"</span>;
<a name="l00090"></a>00090             cerr &lt;&lt; corners.size() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; t.size() &lt;&lt; endl;
<a name="l00091"></a>00091             exit(1);
<a name="l00092"></a>00092         }
<a name="l00093"></a>00093     }
<a name="l00094"></a>00094 
<a name="l00095"></a>00095     vector&lt;ImageRef&gt; ret;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097     <span class="keywordtype">int</span> d = im.size().x;
<a name="l00098"></a>00098     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; corners.size(); i++)
<a name="l00099"></a>00099     {
<a name="l00100"></a>00100         <span class="keywordtype">int</span> o = corners[i];
<a name="l00101"></a>00101         ret.push_back(ImageRef(o %d, o/d));
<a name="l00102"></a>00102     }
<a name="l00103"></a>00103 
<a name="l00104"></a>00104     <span class="keywordflow">return</span> ret;
<a name="l00105"></a>00105 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g017fb812c91723281433113cd04910f7"></a><!-- doxytag: member="faster_tree.cc::tree_detect_corners" ref="g017fb812c91723281433113cd04910f7" args="(const Image&lt; byte &gt; &amp;im, const tree_element *detector, int threshold, Image&lt; int &gt; scores)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;ImageRef&gt; tree_detect_corners           </td>
          <td>(</td>
          <td class="paramtype">const Image&lt; byte &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>im</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtree__element.html">tree_element</a> *&nbsp;</td>
          <td class="paramname"> <em>detector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Image&lt; int &gt;&nbsp;</td>
          <td class="paramname"> <em>scores</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detect corners with nonmaximal suppression in an image. 
<p>
This contains a large amount of configurable debugging code to verify the correctness of the detector by comparing different implementations. High speed is achieved by converting the detector in to <a class="el" href="group__gFastTree.html">bytecode and JIT-compiling if possible</a>.<p>
The function recognises the following GVars:<ul>
<li><code>debug.verify_detections</code> Veryify JIT or bytecode detected corners using <a class="el" href="classtree__element.html#af29dc9bf366f0fa91f474f1c1a4b8fb" title="Apply the tree in all forms to detect a corner.">tree_element::detect_corner</a></li><li><code>debug.verify_scores</code> Veryify bytecode computed scores using <a class="el" href="classtree__element.html#af29dc9bf366f0fa91f474f1c1a4b8fb" title="Apply the tree in all forms to detect a corner.">tree_element::detect_corner</a></li></ul>
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>im</em>&nbsp;</td><td>The image to detect corners in. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>detector</em>&nbsp;</td><td>The corner detector. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>threshold</em>&nbsp;</td><td>The detector threshold. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scores</em>&nbsp;</td><td>This image will be used to store the corner scores for nonmaximal suppression and is the same size as im. It is passed as a parameter since allocation of an image of this size is a significant expense. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="faster__tree_8cc-source.html#l00125">125</a> of file <a class="el" href="faster__tree_8cc-source.html">faster_tree.cc</a>.</p>

<p>References <a class="el" href="faster__tree_8h-source.html#l00050">tree_element::bbox()</a>, <a class="el" href="faster__bytecode_8h-source.html#l00099">block_bytecode::detect()</a>, <a class="el" href="faster__tree_8h-source.html#l00318">tree_element::detect_corner()</a>, and <a class="el" href="faster__tree_8h-source.html#l00092">tree_element::make_fast_detector()</a>.</p>

<p>Referenced by <a class="el" href="learn__detector_8cc-source.html#l00258">learn_detector()</a>, and <a class="el" href="faster__detector_8cc-source.html#l00107">faster_learn::operator()()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00126"></a>00126 {
<a name="l00127"></a>00127     ImageRef tl, br, s;
<a name="l00128"></a>00128     rpair(tl,br) = detector-&gt;<a class="code" href="classtree__element.html#6fc18f7eff889094c9e65835d5879d5e" title="This returns the bounding box of the detector.">bbox</a>();
<a name="l00129"></a>00129     s = im.size();
<a name="l00130"></a>00130 
<a name="l00131"></a>00131     <span class="keywordtype">int</span> ymin = 1 - tl.y, ymax = s.y - 1 - br.y;
<a name="l00132"></a>00132     <span class="keywordtype">int</span> xmin = 1 - tl.x, xmax = s.x - 1 - br.x;
<a name="l00133"></a>00133 
<a name="l00134"></a>00134     ImageRef pos;
<a name="l00135"></a>00135     scores.zero();
<a name="l00136"></a>00136     
<a name="l00137"></a>00137     vector&lt;int&gt; corners;
<a name="l00138"></a>00138     
<a name="l00139"></a>00139     <a class="code" href="structblock__bytecode.html" title="This struct contains a byte code compiled version of the detector.">block_bytecode</a> f2 = detector-&gt;<a class="code" href="group__gFastTree.html#gfd6c958f8187d912041cc3dec8769215" title="Compile the detector to bytecode.">make_fast_detector</a>(im.size().x);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     f2.<a class="code" href="structblock__bytecode.html#5cc546b17c7012c75fabeb3ad552c7fd" title="Detects a corner at a given pointer, with book-keeping required for score computation...">detect</a>(im, corners, threshold, xmin, xmax, ymin, ymax);
<a name="l00142"></a>00142     
<a name="l00143"></a>00143 
<a name="l00144"></a>00144     <span class="keywordflow">if</span>(GV3::get&lt;bool&gt;(<span class="stringliteral">"debug.verify_detections"</span>))
<a name="l00145"></a>00145     {
<a name="l00146"></a>00146         <span class="comment">//Detect corners using slowest, but most obvious detector, since it's most likely to </span>
<a name="l00147"></a>00147         <span class="comment">//be correct.</span>
<a name="l00148"></a>00148         vector&lt;ImageRef&gt; t;
<a name="l00149"></a>00149         <span class="keywordflow">for</span>(pos.y = ymin; pos.y &lt; ymax; pos.y++)
<a name="l00150"></a>00150         {
<a name="l00151"></a>00151             <span class="keywordflow">for</span>(pos.x = xmin; pos.x &lt; xmax; pos.x++)
<a name="l00152"></a>00152                 <span class="keywordflow">if</span>(detector-&gt;<a class="code" href="classtree__element.html#af29dc9bf366f0fa91f474f1c1a4b8fb" title="Apply the tree in all forms to detect a corner.">detect_corner</a>(im, pos, threshold))
<a name="l00153"></a>00153                     t.push_back(pos);
<a name="l00154"></a>00154         }
<a name="l00155"></a>00155 
<a name="l00156"></a>00156         <span class="comment">//Verify detected corners against this result</span>
<a name="l00157"></a>00157         <span class="keywordflow">if</span>(t.size() == corners.size())
<a name="l00158"></a>00158         {
<a name="l00159"></a>00159             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; corners.size(); i++)
<a name="l00160"></a>00160                 <span class="keywordflow">if</span>(im.data() + corners[i] != &amp; im[t[i]])
<a name="l00161"></a>00161                 {
<a name="l00162"></a>00162                     cerr &lt;&lt; <span class="stringliteral">"Fatal error: standard and fast detectors do not match!\n"</span>;
<a name="l00163"></a>00163                     cerr &lt;&lt; <span class="stringliteral">"Same number of corners, but different positions.\n"</span>;
<a name="l00164"></a>00164                     exit(1);
<a name="l00165"></a>00165                 }
<a name="l00166"></a>00166         }
<a name="l00167"></a>00167         <span class="keywordflow">else</span>
<a name="l00168"></a>00168         {
<a name="l00169"></a>00169             cerr &lt;&lt; <span class="stringliteral">"Fatal error: standard and fast detectors do not match!\n"</span>;
<a name="l00170"></a>00170             cerr &lt;&lt; <span class="stringliteral">"Different number of corners detected.\n"</span>;
<a name="l00171"></a>00171             cerr &lt;&lt; corners.size() &lt;&lt; <span class="stringliteral">" "</span> &lt;&lt; t.size() &lt;&lt; endl;
<a name="l00172"></a>00172             exit(1);
<a name="l00173"></a>00173         }
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175 
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 
<a name="l00178"></a>00178     <span class="comment">//Compute scores</span>
<a name="l00179"></a>00179     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; corners.size(); j++)
<a name="l00180"></a>00180     {
<a name="l00181"></a>00181         <span class="keywordtype">int</span> i=threshold + 1;
<a name="l00182"></a>00182         <span class="keywordflow">while</span>(1)
<a name="l00183"></a>00183         {
<a name="l00184"></a>00184             <span class="keywordtype">int</span> n = f2.<a class="code" href="structblock__bytecode.html#5cc546b17c7012c75fabeb3ad552c7fd" title="Detects a corner at a given pointer, with book-keeping required for score computation...">detect</a>(im.data() + corners[j], i);
<a name="l00185"></a>00185             <span class="keywordflow">if</span>(n != 0)
<a name="l00186"></a>00186                 i += n;
<a name="l00187"></a>00187             <span class="keywordflow">else</span>
<a name="l00188"></a>00188                 <span class="keywordflow">break</span>;
<a name="l00189"></a>00189         }
<a name="l00190"></a>00190         scores.data()[corners[j]] = i-1;
<a name="l00191"></a>00191     }
<a name="l00192"></a>00192 
<a name="l00193"></a>00193     <span class="keywordflow">if</span>(GV3::get&lt;bool&gt;(<span class="stringliteral">"debug.verify_scores"</span>))
<a name="l00194"></a>00194     {
<a name="l00195"></a>00195         <span class="comment">//Compute scores using the obvious, but slow recursive implementation.</span>
<a name="l00196"></a>00196         <span class="comment">//This can be used to test the no obvious FAST implementation and the</span>
<a name="l00197"></a>00197         <span class="comment">//non obviouser JIT implementation, if it ever exists.</span>
<a name="l00198"></a>00198         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; corners.size(); j++)
<a name="l00199"></a>00199         {
<a name="l00200"></a>00200             <span class="keywordtype">int</span> i=threshold + 1;
<a name="l00201"></a>00201             ImageRef pos =  im.pos(im.data() + corners[j]);
<a name="l00202"></a>00202             <span class="keywordflow">while</span>(1)
<a name="l00203"></a>00203             {
<a name="l00204"></a>00204                 <span class="keywordtype">int</span> n = detector-&gt;<a class="code" href="classtree__element.html#af29dc9bf366f0fa91f474f1c1a4b8fb" title="Apply the tree in all forms to detect a corner.">detect_corner</a>(im, pos, i);
<a name="l00205"></a>00205                 <span class="keywordflow">if</span>(n != 0)
<a name="l00206"></a>00206                     i += n;
<a name="l00207"></a>00207                 <span class="keywordflow">else</span>
<a name="l00208"></a>00208                     <span class="keywordflow">break</span>;
<a name="l00209"></a>00209             }
<a name="l00210"></a>00210 
<a name="l00211"></a>00211             <span class="keywordflow">if</span>(scores.data()[corners[j]] != i-1)
<a name="l00212"></a>00212             {
<a name="l00213"></a>00213                 cerr &lt;&lt; <span class="stringliteral">"Fatal error: standard and fast scores do not match!\n"</span>;
<a name="l00214"></a>00214                 cerr &lt;&lt; <span class="stringliteral">"Different score detected at  "</span> &lt;&lt; pos &lt;&lt; endl;
<a name="l00215"></a>00215                 exit(1);
<a name="l00216"></a>00216             }
<a name="l00217"></a>00217         }
<a name="l00218"></a>00218     }
<a name="l00219"></a>00219 
<a name="l00220"></a>00220     
<a name="l00221"></a>00221     <span class="comment">//Perform non-max suppression the simple way</span>
<a name="l00222"></a>00222     vector&lt;ImageRef&gt; nonmax;
<a name="l00223"></a>00223     <span class="keywordtype">int</span> d = im.size().x;
<a name="l00224"></a>00224     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; corners.size(); i++)
<a name="l00225"></a>00225     {
<a name="l00226"></a>00226         <span class="keywordtype">int</span> o = corners[i];
<a name="l00227"></a>00227         <span class="keywordtype">int</span> v = scores.data()[o];
<a name="l00228"></a>00228 
<a name="l00229"></a>00229         <span class="keywordflow">if</span>( v &gt; *(scores.data() + o + 1    )  &amp;&amp;
<a name="l00230"></a>00230             v &gt; *(scores.data() + o - 1    )  &amp;&amp;
<a name="l00231"></a>00231             v &gt; *(scores.data() + o +d + 1 )  &amp;&amp;
<a name="l00232"></a>00232             v &gt; *(scores.data() + o +d     )  &amp;&amp;
<a name="l00233"></a>00233             v &gt; *(scores.data() + o +d - 1 )  &amp;&amp;
<a name="l00234"></a>00234             v &gt; *(scores.data() + o -d + 1 )  &amp;&amp;
<a name="l00235"></a>00235             v &gt; *(scores.data() + o -d     )  &amp;&amp;
<a name="l00236"></a>00236             v &gt; *(scores.data() + o -d - 1))
<a name="l00237"></a>00237         {
<a name="l00238"></a>00238             nonmax.push_back(ImageRef(o %d, o/d));
<a name="l00239"></a>00239         }
<a name="l00240"></a>00240     }
<a name="l00241"></a>00241 
<a name="l00242"></a>00242     <span class="keywordflow">return</span> nonmax;
<a name="l00243"></a>00243 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g0f1555100a7d28f0454b6ae04f4183b1"></a><!-- doxytag: member="faster_tree.cc::load_a_tree" ref="g0f1555100a7d28f0454b6ae04f4183b1" args="(istream &amp;i, bool eq_branch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree__element.html">tree_element</a>* load_a_tree           </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>eq_branch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses a <a class="el" href="structtree.html" title="This class represents a decision tree.">tree</a> from an istream. 
<p>
This will deserialize a <a class="el" href="structtree.html" title="This class represents a decision tree.">tree</a> serialized by <a class="el" href="classtree__element.html#da6d8d9fb3c070720758234b44c9cc43" title="Serialize the tree.">tree_element::print()</a>. On error, <a class="el" href="structParseError.html" title="A named symbol to throw in the case that tree deserialization fails with a parse...">ParseError</a> is thrown. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The stream to parse </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eq_branch</em>&nbsp;</td><td>Is it an EQ branch? Check the invariant. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An allocated <a class="el" href="structtree.html" title="This class represents a decision tree.">tree</a>. Ownership is passed to the callee. </dd></dl>

<p>Definition at line <a class="el" href="faster__tree_8cc-source.html#l00287">287</a> of file <a class="el" href="faster__tree_8cc-source.html">faster_tree.cc</a>.</p>

<p>References <a class="el" href="fast__N__features_8cc-source.html#l00052">is_corner()</a>, and <a class="el" href="faster__tree_8cc-source.html#l00249">split()</a>.</p>

<p>Referenced by <a class="el" href="faster__detector_8cc-source.html#l00072">faster_learn::faster_learn()</a>, <a class="el" href="faster__tree_8cc-source.html#l00334">load_a_tree()</a>, and <a class="el" href="extract__features_8cc-source.html#l00094">main()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00288"></a>00288 {   
<a name="l00289"></a>00289     <span class="keywordtype">string</span> line;
<a name="l00290"></a>00290     getline(i, line);
<a name="l00291"></a>00291 
<a name="l00292"></a>00292     vector&lt;string&gt; tok = <a class="code" href="group__gUtility.html#g21228818f6b97bdd706d7980b74a2966" title="Tokenise a string.">split</a>(line);
<a name="l00293"></a>00293 
<a name="l00294"></a>00294     <span class="keywordflow">if</span>(tok.size() == 0)
<a name="l00295"></a>00295         <span class="keywordflow">throw</span> <a class="code" href="structParseError.html" title="A named symbol to throw in the case that tree deserialization fails with a parse...">ParseError</a>();
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     <span class="keywordflow">if</span>(tok[0] == <span class="stringliteral">"Is"</span>)
<a name="l00298"></a>00298     {
<a name="l00299"></a>00299         <span class="keywordflow">if</span>(tok.size() != 7)
<a name="l00300"></a>00300             <span class="keywordflow">throw</span> <a class="code" href="structParseError.html" title="A named symbol to throw in the case that tree deserialization fails with a parse...">ParseError</a>();
<a name="l00301"></a>00301 
<a name="l00302"></a>00302         <span class="keywordtype">bool</span> <a class="code" href="fast__N__features_8cc.html#541e8aa66ec0c498e9036c39b859dd86" title="Determine if a string has the properties of a FAST-N corner.">is_corner</a> = ato&lt;bool&gt;(tok[2]);
<a name="l00303"></a>00303 
<a name="l00304"></a>00304         <span class="keywordflow">if</span>(eq_branch &amp;&amp; is_corner)
<a name="l00305"></a>00305         {
<a name="l00306"></a>00306             cerr &lt;&lt; <span class="stringliteral">"Warning: Fixing invariant in tree\n"</span>;
<a name="l00307"></a>00307             is_corner=0;
<a name="l00308"></a>00308         }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310         <span class="keywordflow">return</span> <span class="keyword">new</span> <a class="code" href="classtree__element.html" title="This struct represents a node of the tree, and has pointers to other structs, thereby...">tree_element</a>(is_corner);
<a name="l00311"></a>00311     }
<a name="l00312"></a>00312     <span class="keywordflow">else</span>
<a name="l00313"></a>00313     {
<a name="l00314"></a>00314         <span class="keywordflow">if</span>(tok.size() != 5)
<a name="l00315"></a>00315             <span class="keywordflow">throw</span> <a class="code" href="structParseError.html" title="A named symbol to throw in the case that tree deserialization fails with a parse...">ParseError</a>();
<a name="l00316"></a>00316 
<a name="l00317"></a>00317         <span class="keywordtype">int</span> offset = ato&lt;int&gt;(tok[0]);
<a name="l00318"></a>00318 
<a name="l00319"></a>00319         auto_ptr&lt;tree_element&gt; t1(<a class="code" href="group__gTree.html#g0f1555100a7d28f0454b6ae04f4183b1" title="Parses a tree from an istream.">load_a_tree</a>(i, <span class="keyword">false</span>));
<a name="l00320"></a>00320         auto_ptr&lt;tree_element&gt; t2(<a class="code" href="group__gTree.html#g0f1555100a7d28f0454b6ae04f4183b1" title="Parses a tree from an istream.">load_a_tree</a>(i, <span class="keyword">true</span>));
<a name="l00321"></a>00321         auto_ptr&lt;tree_element&gt; t3(<a class="code" href="group__gTree.html#g0f1555100a7d28f0454b6ae04f4183b1" title="Parses a tree from an istream.">load_a_tree</a>(i, <span class="keyword">false</span>));
<a name="l00322"></a>00322         auto_ptr&lt;tree_element&gt; ret(<span class="keyword">new</span> <a class="code" href="classtree__element.html" title="This struct represents a node of the tree, and has pointers to other structs, thereby...">tree_element</a>(t1.release(), t2.release(), t3.release(), offset)); 
<a name="l00323"></a>00323 
<a name="l00324"></a>00324         <span class="keywordflow">return</span> ret.release();
<a name="l00325"></a>00325 
<a name="l00326"></a>00326     }
<a name="l00327"></a>00327 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="gfe0dbc486b500351caf686a7a7701583"></a><!-- doxytag: member="faster_tree.cc::load_a_tree" ref="gfe0dbc486b500351caf686a7a7701583" args="(istream &amp;i)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtree__element.html">tree_element</a>* load_a_tree           </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&nbsp;</td>
          <td class="paramname"> <em>i</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Parses a <a class="el" href="structtree.html" title="This class represents a decision tree.">tree</a> from an istream. 
<p>
This will deserialize a <a class="el" href="structtree.html" title="This class represents a decision tree.">tree</a> serialized by <a class="el" href="classtree__element.html#da6d8d9fb3c070720758234b44c9cc43" title="Serialize the tree.">tree_element::print()</a>. On error, <a class="el" href="structParseError.html" title="A named symbol to throw in the case that tree deserialization fails with a parse...">ParseError</a> is thrown. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>i</em>&nbsp;</td><td>The stream to parse </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>An allocated <a class="el" href="structtree.html" title="This class represents a decision tree.">tree</a>. Ownership is passed to the callee. </dd></dl>

<p>Definition at line <a class="el" href="faster__tree_8cc-source.html#l00334">334</a> of file <a class="el" href="faster__tree_8cc-source.html">faster_tree.cc</a>.</p>

<p>References <a class="el" href="faster__tree_8cc-source.html#l00287">load_a_tree()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00335"></a>00335 {
<a name="l00336"></a>00336     <span class="keywordflow">return</span> <a class="code" href="group__gTree.html#g0f1555100a7d28f0454b6ae04f4183b1" title="Parses a tree from an istream.">load_a_tree</a>(i, <span class="keyword">true</span>);
<a name="l00337"></a>00337 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="g94713e5d6106835e08d8630988b823d2"></a><!-- doxytag: member="offsets.cc::transform_offsets" ref="g94713e5d6106835e08d8630988b823d2" args="(const vector&lt; ImageRef &gt; &amp;offsets, int angle, bool r)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;ImageRef&gt; transform_offsets           </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; ImageRef &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>r</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Rotate a vector&lt;ImageRef&gt; by a given angle, with an optional reflection. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>offsets</em>&nbsp;</td><td>Offsets to rotate. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>angle</em>&nbsp;</td><td>Angle to rotate by. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>r</em>&nbsp;</td><td>Whether to reflect. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The rotated offsets. </dd></dl>

<p>Definition at line <a class="el" href="offsets_8cc-source.html#l00066">66</a> of file <a class="el" href="offsets_8cc-source.html">offsets.cc</a>.</p>

<p>References <a class="el" href="utility_8h-source.html#l00030">ir_rounded()</a>.</p>

<p>Referenced by <a class="el" href="offsets_8cc-source.html#l00156">create_offsets()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00067"></a>00067 {
<a name="l00068"></a>00068     <span class="keywordtype">double</span> a = angle * M_PI / 2;    
<a name="l00069"></a>00069 
<a name="l00070"></a>00070     <span class="keywordtype">double</span> R_[] = { cos(a), sin(a), -sin(a) , cos(a) };
<a name="l00071"></a>00071     <span class="keywordtype">double</span> F_[] = { 1, 0, 0, r?-1:1};
<a name="l00072"></a>00072 
<a name="l00073"></a>00073     Matrix&lt;2&gt; R(R_), F(F_);
<a name="l00074"></a>00074     Matrix&lt;2&gt; T = R*F;
<a name="l00075"></a>00075 
<a name="l00076"></a>00076     vector&lt;ImageRef&gt; ret;
<a name="l00077"></a>00077 
<a name="l00078"></a>00078     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; <a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>.size(); i++)
<a name="l00079"></a>00079     {
<a name="l00080"></a>00080         Vector&lt;2&gt; v = vec(<a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[i]);
<a name="l00081"></a>00081         ret.push_back(<a class="code" href="group__gUtility.html#g4a600719fba70d96ffb0dac6466a7659" title="Convert a float array into an image co-ordinate.">ir_rounded</a>(T * v));
<a name="l00082"></a>00082     }
<a name="l00083"></a>00083     
<a name="l00084"></a>00084     <span class="keywordflow">return</span> ret;
<a name="l00085"></a>00085 }
</pre></div>
<p>

</div>
</div><p>
<a class="anchor" name="ge4ead2482e17e068c6ca4dae2e055eca"></a><!-- doxytag: member="offsets.cc::create_offsets" ref="ge4ead2482e17e068c6ca4dae2e055eca" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void create_offsets           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create a list of offsets with various transformation to map the offset number (see Figure 7 in the accompanying paper) to a pixel coordinate, inclusing all combinations of rotation and reflection. 
<p>
The function populates <a class="el" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>, and must be called before anything uses this variable.<p>
All possible offsets are selected in an annulus, which uses the following gvars:<ul>
<li><code>offsets.min_radius</code> Minimum distance from (0,0) for offset</li><li><code>offsets.max_radius</code> Maximum distance from (0,0) for offset </li></ul>

<p>Definition at line <a class="el" href="offsets_8cc-source.html#l00156">156</a> of file <a class="el" href="offsets_8cc-source.html">offsets.cc</a>.</p>

<p>Referenced by <a class="el" href="extract__features_8cc-source.html#l00094">main()</a>, and <a class="el" href="learn__detector_8cc-source.html#l00522">run_learn_detector()</a>.</p>
<div class="fragment"><pre class="fragment"><a name="l00157"></a>00157 {
<a name="l00158"></a>00158     <span class="comment">//Pixel offsets are represented as integer indices in to an array of</span>
<a name="l00159"></a>00159     <span class="comment">//ImageRefs. That means that by choosing the array, the tree can be</span>
<a name="l00160"></a>00160     <span class="comment">//rotated and/or reflected. Here, an annulus of possible offsets is </span>
<a name="l00161"></a>00161     <span class="comment">//created and rotated by all multiples of 90 degrees, and then reflected.</span>
<a name="l00162"></a>00162     <span class="comment">//This gives a total of 8.</span>
<a name="l00163"></a>00163     <a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>.resize(8);
<a name="l00164"></a>00164     {   
<a name="l00165"></a>00165         <span class="keywordtype">double</span> min_r = GV3::get&lt;double&gt;(<span class="stringliteral">"offsets.min_radius"</span>);
<a name="l00166"></a>00166         <span class="keywordtype">double</span> max_r = GV3::get&lt;double&gt;(<span class="stringliteral">"offsets.max_radius"</span>);
<a name="l00167"></a>00167 
<a name="l00168"></a>00168         ImageRef max((<span class="keywordtype">int</span>)ceil(max_r+1), (<span class="keywordtype">int</span>)ceil(max_r+1));
<a name="l00169"></a>00169         ImageRef min = -max, p = min;
<a name="l00170"></a>00170 
<a name="l00171"></a>00171         <span class="comment">//cout &lt;&lt; "Offsets: ";</span>
<a name="l00172"></a>00172 
<a name="l00173"></a>00173         <span class="keywordflow">do</span>
<a name="l00174"></a>00174         {
<a name="l00175"></a>00175             <span class="keywordtype">double</span> d = vec(p) * vec(p);
<a name="l00176"></a>00176 
<a name="l00177"></a>00177             <span class="keywordflow">if</span>(d &gt;= min_r*min_r &amp;&amp; d &lt;= max_r * max_r)
<a name="l00178"></a>00178             {
<a name="l00179"></a>00179                 <a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[0].push_back(p);
<a name="l00180"></a>00180                 <span class="comment">//cout &lt;&lt; offsets[0].back() &lt;&lt; " ";</span>
<a name="l00181"></a>00181             }
<a name="l00182"></a>00182         }
<a name="l00183"></a>00183         <span class="keywordflow">while</span>(p.next(min, max));
<a name="l00184"></a>00184 
<a name="l00185"></a>00185     <span class="comment">//  cout &lt;&lt; endl;</span>
<a name="l00186"></a>00186 
<a name="l00187"></a>00187         <a class="code" href="group__gTree.html#g1fc640c768404e037aa3b77668bfd9a5" title="Bounding box for offsets in all orientations.">offsets_bbox</a> = make_pair(min, max);
<a name="l00188"></a>00188     }
<a name="l00189"></a>00189     <a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[1] = <a class="code" href="group__gTree.html#g94713e5d6106835e08d8630988b823d2" title="Rotate a vector&amp;lt;ImageRef&amp;gt; by a given angle, with an optional reflection.">transform_offsets</a>(<a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[0], 1, 0);
<a name="l00190"></a>00190     <a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[2] = <a class="code" href="group__gTree.html#g94713e5d6106835e08d8630988b823d2" title="Rotate a vector&amp;lt;ImageRef&amp;gt; by a given angle, with an optional reflection.">transform_offsets</a>(<a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[0], 2, 0);
<a name="l00191"></a>00191     <a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[3] = <a class="code" href="group__gTree.html#g94713e5d6106835e08d8630988b823d2" title="Rotate a vector&amp;lt;ImageRef&amp;gt; by a given angle, with an optional reflection.">transform_offsets</a>(<a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[0], 3, 0);
<a name="l00192"></a>00192     <a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[4] = <a class="code" href="group__gTree.html#g94713e5d6106835e08d8630988b823d2" title="Rotate a vector&amp;lt;ImageRef&amp;gt; by a given angle, with an optional reflection.">transform_offsets</a>(<a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[0], 0, 1);
<a name="l00193"></a>00193     <a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[5] = <a class="code" href="group__gTree.html#g94713e5d6106835e08d8630988b823d2" title="Rotate a vector&amp;lt;ImageRef&amp;gt; by a given angle, with an optional reflection.">transform_offsets</a>(<a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[0], 1, 1);
<a name="l00194"></a>00194     <a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[6] = <a class="code" href="group__gTree.html#g94713e5d6106835e08d8630988b823d2" title="Rotate a vector&amp;lt;ImageRef&amp;gt; by a given angle, with an optional reflection.">transform_offsets</a>(<a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[0], 2, 1);
<a name="l00195"></a>00195     <a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[7] = <a class="code" href="group__gTree.html#g94713e5d6106835e08d8630988b823d2" title="Rotate a vector&amp;lt;ImageRef&amp;gt; by a given angle, with an optional reflection.">transform_offsets</a>(<a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[0], 3, 1);
<a name="l00196"></a>00196     <a class="code" href="group__gTree.html#g0b909fc1924609a5bb0dc4a364193edb" title="The number of possible offsets.">num_offsets</a>=<a class="code" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672" title="Actual x,y offset of the offset numbers in the different available orientations.">offsets</a>[0].size();
<a name="l00197"></a>00197 }
</pre></div>
<p>

</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="gba2611edc3d025abd67eb4d57c5e9672"></a><!-- doxytag: member="offsets.cc::offsets" ref="gba2611edc3d025abd67eb4d57c5e9672" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;vector&lt;ImageRef&gt; &gt; <a class="el" href="group__gTree.html#gba2611edc3d025abd67eb4d57c5e9672">offsets</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Actual x,y offset of the offset numbers in the different available orientations. 
<p>

<p>Definition at line <a class="el" href="offsets_8cc-source.html#l00049">49</a> of file <a class="el" href="offsets_8cc-source.html">offsets.cc</a>.</p>

<p>Referenced by <a class="el" href="offsets_8cc-source.html#l00156">create_offsets()</a>, <a class="el" href="faster__tree_8h-source.html#l00318">tree_element::detect_corner()</a>, <a class="el" href="faster__tree_8h-source.html#l00282">tree_element::detect_corner_oriented()</a>, <a class="el" href="offsets_8cc-source.html#l00201">draw_offsets()</a>, <a class="el" href="extract__features_8cc-source.html#l00067">extract_feature()</a>, <a class="el" href="extract__features_8cc-source.html#l00094">main()</a>, <a class="el" href="faster__tree_8h-source.html#l00092">tree_element::make_fast_detector()</a>, and <a class="el" href="faster__tree_8h-source.html#l00175">tree_element::make_fast_detector_o()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g0b909fc1924609a5bb0dc4a364193edb"></a><!-- doxytag: member="offsets.cc::num_offsets" ref="g0b909fc1924609a5bb0dc4a364193edb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="group__gTree.html#g0b909fc1924609a5bb0dc4a364193edb">num_offsets</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
The number of possible offsets. 
<p>
Equivalent to <code>offsets[x].size()</code> 
<p>Definition at line <a class="el" href="offsets_8cc-source.html#l00052">52</a> of file <a class="el" href="offsets_8cc-source.html">offsets.cc</a>.</p>

<p>Referenced by <a class="el" href="offsets_8cc-source.html#l00156">create_offsets()</a>, <a class="el" href="extract__features_8cc-source.html#l00067">extract_feature()</a>, <a class="el" href="learn__detector_8cc-source.html#l00258">learn_detector()</a>, <a class="el" href="extract__features_8cc-source.html#l00094">main()</a>, and <a class="el" href="learn__detector_8cc-source.html#l00218">random_tree()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g1fc640c768404e037aa3b77668bfd9a5"></a><!-- doxytag: member="offsets.cc::offsets_bbox" ref="g1fc640c768404e037aa3b77668bfd9a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;ImageRef, ImageRef&gt; <a class="el" href="group__gTree.html#g1fc640c768404e037aa3b77668bfd9a5">offsets_bbox</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bounding box for offsets in all orientations. 
<p>
This is therefore a bounding box for the detector. 
<p>Definition at line <a class="el" href="offsets_8cc-source.html#l00055">55</a> of file <a class="el" href="offsets_8cc-source.html">offsets.cc</a>.</p>

<p>Referenced by <a class="el" href="faster__tree_8h-source.html#l00050">tree_element::bbox()</a>, <a class="el" href="offsets_8cc-source.html#l00156">create_offsets()</a>, and <a class="el" href="extract__features_8cc-source.html#l00094">main()</a>.</p>

</div>
</div><p>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Nov 5 10:25:01 2008 for FAST-ER by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
